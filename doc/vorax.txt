*vorax.txt*   Plugin for working with Oracle databases.
            For vim version 7.x

			       By Alexandru TicÄƒ
		     alexandru.tica email-at-sign gmail.com

                                                        *vorax* *vorax-plugin*

	Contents:
	   What is VoraX .......................... |vorax-whatis|
	   Features ............................... |vorax-features|
	   Architecture ........................... |vorax-architecture|
	   Installation Guide ..................... |vorax-install|
	   Connecting to a database ............... |vorax-connect|
	   Executing statements ................... |vorax-exec|
	   The output window  ..................... |vorax-output|
	   The code completion system ............. |vorax-omni|
	   The database explorer .................. |vorax-expolorer|


==============================================================================
WHAT IS VORAX                                                     *vorax-whatis*

VoraX is a minimalist Oracle IDE based on the well known Vim editor. The main
reasons which motivate us to develop this plugin are:

	- the power of Vim editor. When applied to Oracle development or 
	  database administration it brings a lot of efficiency and fun.

	- the need for a cross platform tool. Vim editor is available on many
	  platforms which means you're free to use whatever OS you like.

	- availability as a console IDE. Having a shiny IDE on a slow SSH
	  connection doesn't sound so good, does it? A DBA will be pleased 
	  running VoraX in a console because, usually, is so used running OS 
	  commands, scripts etc. and, of course, the terminal is his best 
	  friend. With VoraX in place you don't need to leave your beloved 
	  console anymore.

	- having an IDE with a very small footprint. VoraX is nothing but a 
	  collection of VimL and Ruby scripts provided as a Vim plugin. We 
	  hope VoraX will consume as less resources as possible.

	- the dream of an improved SqlPLUS environment. I know a lot of guys
	  (including me) who intensively use SqlPLUS, even for complex tasks. 
	  On the other hand its limitations are quite annoying: we want good 
	  code completion, pretty print output and so on. We cannot get rid of 
	  SqlPLUS because we still think it is a great tool but we can make it 
	  better. This is another goal of VoraX.

VoraX stands for Vim ORAcle eXtension. It acts like a wrapper on the SqlPLUS
environment. Every call to the database is made through SqlPLUS but in a
hidden way so that the user is not aware of that. This approach has pros and
cons. From one hand it inherits all those nice SqlPLUS features like explain
plans, column computations and so on, but on the other hand it has to deal
with all the limitations of the SqlPLUS (formatting output, syntax highlight
etc.) To fill this gap is the whole idea of VoraX.

==============================================================================
FEATURES                                                        *vorax-features*

VoraX comes with the following features:

	- Advanced code completion for database object names, columns, aliases
	  and procedure/function parameters;

	- A database objects browser. You may browse tables, views, packages
	  and so on. The options available for every type of object may be
	  extended through custom plugins;

	- Connection profiles. VoraX allows to store various connection
	  strings, including the corresponding passwords. All these passwords
	  are protected using a master password.
	
	- An output window where the results of running various statements are
	  displayed. Within this window logging may be started in order to
	  save everything is output into a file on disk for future inspection.
	
	- Support for editing and compiling PL/SQL modules like packages,
	  types, procedure and functions.

	- Convenient key mappings for: describe object under cursor, execute
	  current statement etc. 
	
	- Pretty print output. You may switch to a vertical columns output or
	  to a compressed format. In a compressed output all columns width are
	  resized according to the length of the contained data.

==============================================================================
ARCHITECTURE                                                *vorax-architecture*

VoraX is based on SqlPLUS to interact with the database. Every statement you
execute using VoraX is actually run by SqlPLUS behind. When VoraX is
initialized a SqlPLUS process is started in background. Then VoraX
communicates with this process by sending commands and grabbing the
corresponding output.

Maintaining this SqlPLUS process is done differently based on the current OS
platform. On *NIX, VoraX communicates with SqlPLUS using PTYs, on Windows
this communication is done with Windows PIPEs.

In order to be able to implement this kind of interaction, VoraX uses Ruby
language. Even we'd like to have a pure VimL implementation that isn't yet
possible. However, we tried to limit developing VoraX features in Ruby as much
as possible and use VimL instead. Nevertheless, parsing html output, writing
and parsing Oracle grammars for code completion and other complex tasks are
still written in Ruby.

==============================================================================
INSTALLATION GUIDE                                               *vorax-install* 

VoraX follows the standard procedure of installing a Vim plugin: uncompress
the vorax archive into $HOME/.vim if you are on a *NIX platform or into
$HOME/vimfiles if you are on Windows. If you want VoraX to be available for
all users then you may consider installing VoraX in your Vim HOME location. 

You may also use Pathogen, vim-addon-manager or other similar addons management
plugins if you want. It's completely up to you!

However, you need to take care of some dependencies VoraX relies on: 

   1. Vim 7.3 or above is required.

   2. Your Vim must have ruby support enabled. In order to check this you may 
      execute :version and look for +ruby. The supported Ruby is 1.8.7. To 
      check this you may run the following command within your Vim editor:
      
      :ruby puts RUBY_VERSION
      
      CREAM configurations are not supported therefore a plain Vim should be 
      used.

   3. Ruby 1.8.7

   4. Rubygems. On Debian systems is as simple as: 
   
      sudo apt-get install rubygems

   5. The following gems:

	- gem install antlr3 -r
	- gem install activesupport -r
	- gem install nokogiri -r

   6. A working Oracle client with SqlPLUS, which has to be available in the 
      environment $PATH variable. The instant client with SqlPLUS should be 
      just fine.

   7. Optionally, if you want to securely store passwords for your Oracle 
      connections then the openssl ruby extension must be available. 
      On Ubuntu/Debian systems you may use the following command to install it: 
      
      sudo apt-get install libopenssl-ruby1.8 

In addition the following Vim script must be also installed:

   - TLib: http://www.vim.org/scripts/script.php?script_id=1863

Also, it's best to have "filetype plugin on" in your .vimrc file.

==============================================================================
CONNECTING TO A DATABASE				         *vorax-connect* 

The simplest method to connect to a new database is to use the VoraxConnect
command. For example, the following command is used to connect to an imaginary
TESTDB database with SCOTT user:

		       :VoraxConnect scott/tiger@testdb

On a successful connect you'll be welcomed with the usual Oracle SqlPLUS
banner, otherwise the corresponding error will be displayed.

Sometimes you want to organize all these connection strings in some kind of a
repository for further reference. For this kind of functionality VoraX
provides a connection profile window. To activate it just execute:

			  :VoraxProfilesWindowToggle

There's also a default mapping for toggling this window: <Leader>pr. It's easy
to memorize it: "pr" stands for PRofiles.

Of course, at the very beginning, no profiles are configured. To add a new
profile, while you are in this window, you must display the contextual menu by
pressing <Tab>. This key is the default one, but you're free to choose another
one if you don't like it. From this menu you may select the option to create a 
new connection profile and then to enter the following:

	1. A connection string (e.g. scott@testdb).
	2. A category (e.g. Development or Production etc.).
	3. An importance flag. This is used to display this profile with a
	distinct color in order to underline that it's about a powerful user.
	For example, a connection profile with SYS might be a good candidate
	for this kind of flag.

If the provided connection string contains also the password (e.g.
scott/tiger@testdb) then VoraX will automatically figure out that it must
create a secured repository for you. You'll be prompted for a master password
and then all Oracle passwords will be securely stored in this repository.
Thus, you don't need to remember a lot of passwords but just the master one.

Having these profiles configured is quite handy because VoraxConnect
command is aware of them and you can use completion instead of typing the
entire connection string.

VoraxConnect command accepts also a bang (!). When used like this (e.g.
VoraxConnect! scott/tiger@testdb) the SqlPLUS shadow process is recreated.
Without a bang, the same SqlPLUS process is reused. Usually you don't use this
bang version except for:

	1. The SqlPLUS process is unresponsive and must be recreated.
	2. You want to change the current directory seen by SqlPLUS. In this
	case you may change the current folder in Vim and then force a
	reconnect so that the newly created SqlPLUS process to be started
	from the current location.

==============================================================================
EXECUTING STATEMENTS    				            *vorax-exec* 

In SqlPLUS you just write the statement on the SQL> prompt, press ENTER and
you have the results back with the SQL> prompt waiting for you, again, to 
provide another statement. In VoraX is a bit different. You don't have an 
SQL> prompt but an entire Vim sql buffer where you can write various statements 
and run them from there. It's more like in a PL/SQL Developer or Toad SQL 
window.

Executing SQL statements is allowed just in sql buffers. This is important in
order to avoid any further frustrations or misunderstandings. Don't expect to
have VoraX functionality in the [No Name] buffer or in a python one.

If you want to start executing sql statements right away and need an sql
buffer, VoraX provides a so called "SQL scratch buffer". To open a scratch press
<Leader>ss. It's easy: ss stands for "SQL Scratch". Changing this buffer will
not ask you to save its content so it's important to realize that this scratch
is just a playground. If you care about your SQL statements and want them 
stored in a file then you must use a real sql buffer. For example:

			       :e my_script.sql

Being an sql buffer VoraX will work without a problem.

To execute a statement, VoraX provides a standard keymap: <Leader>e. If you
want to easily remember this keymap just think of "exec". Yes, "e" stands for
"exec". Now, you may execute the current statement or the current selection.
In the first case the current statement is assumed to be the one between two
SQL separators. For example, supposing we have the following:

		select * from cat;
		select count(1) from (select * from v$session)
		/
		exec dbms_output.put_line('abc');

and the cursor is located on the second line. When the user press <Leader>e
then VoraX will know that it must execute the current statement and will try
to detect it using a simple algorithm: find the previous SQL separator (in
this case ";"), find the next SQL separator (in this case /) and execute
everything in between. 

However, as I already mentioned, it's also possible to execute a selection.
For example, if we were to come back to the previous sql buffer and want to
execute just "select * from v$session" then we can visually select that part
and press <Leader>e. Only the selected text will be executed. VoraX will also
take care to add the proper SQL separator at the end of the statement.

In SqlPLUS, a statement may contain substitution variables. The user will be
asked to provide the corresponding values at the execution time. From VoraX 
point of view this is tricky because it sends the statement to SqlPLUS
to be executed and then waits for the results, but in this case it will wait
indefinitely because SqlPLUS also waits for the substitution variables values
to be provided. Unfortunately, VoraX cannot figure out if a statement takes a
lot of time simply because it's a long running command or the execution is
stuck because SqlPLUS asks the user to enter some data. However, it's easy to
figure out if something must be provided by the user by simply looking at the
output.

Suppose you have the following script:

		accept x prompt "Enter x: "
		prompt &x

When you run it the output window will be updated with:

Enter x:

and the "Executing..." indicator will spin continuously at the bottom,
indicating that the statement is still running. The output is self explanatory
and it's pretty clear that we have to provide a value for "x". To provide this
value you have to press <Enter>. VoraX will display a prompt at the bottom
where you can enter this value, which is further sent to SqlPLUS and the
execution will continue with the next statements from the script.

By default VoraX spits the output as soon as it is available into the SqlPLUS
buffer. Yet, as you'll see reading into the next section, VoraX may collect
all output, process it, and at the end the final formatted result will be shown 
(it's the case of the compressed/vertical output). In this case you cannot 
figure out if you wait in an actual execution time or something is required to 
be entered, simply because there is no output available yet. That's why VoraX 
will always peek into the output spit by SqlPLUS and will display the last read
chunk of data as part of the "Executing..." indicator spinner. For example,
running the above script will show the following status:

(Waiting in prompt or slow fetch). <CR> to input at prompt = [...Enter x: ] 

Thus the possible prompt is displayed even no output was written yet into the
output window. This means you still can figure out if SqlPLUS is waiting for
some data to be entered or it is waiting for a long running statement to
complete.

==============================================================================
THE OUTPUT WINDOW    				                  *vorax-output* 

The result returned by the commands you execute is displayed into the output
window. This window is automatically opened whenever something need to be
shown (typically after an exec).

You can choose between two modes:

	1. Clear the output window before executing something. This means
	you'll always have the results from the last command only.

	2. Append the output of the next SQL command to the already existing
	content (this is the default).

You can use the |g:vorax_output_window_clear_before_exec| to control how the
output window should behave.

The output window has its own status line which, by default, displays the
database you're currently logged on, output formatting options and other
useful information. If you don't like the default configuration of this status
line you're free to override it using the |g:vorax_output_window_statusline|
variable.

You can always clear the output window using "cle" keymap. This is a buffer
mapping and, in order to work, you have to be within that window. "cle" stands
for CLEar.

Sometimes the default SqlPLUS columns formatting is not suitable even for
large lines. For example, querying the DBA_DATA_FILE view will display a very
long FILE_NAME column. Of course you can always use COLUMN FORMAT command but
if you have to deal with many such columns this task becomes pretty annoying.
That's why VoraX provides some standard output formats:

	- The compressed output.
	- The vertical output layout.

The compressed output may be activated using <Leader>co. "co" stands for
"Compressed Output". Pressing <Leader>co once again will deactivate this format. 
In a compressed layout, the column width is automatically adjusted according to 
its content. Unlike the default output, in a compressed layout you don't get
immediate feedback because, in order to compress, all records must be
fetched. So, a query on a big table without a filter using the compressed
output is not a good idea.

The vertical output displays each record like a card:

	Column 1: <value>
	Column 2: <value>
	----------------------------
	Column 1: <value>
	Column 2: <value>

Sometimes is better to scroll vertically. This output format may be activated
using <Leader>vo. "vo" stands for "Vertical Output". This mapping acts like a
toggle.

The output window can be also paginated. This is useful when you want to
inspect the output page by page. When paginating is in place after every page
the output flow is interrupted and resumed on user confirmation. To activate
pagination use <Leader>pa. "pa" stands for "PAginating".

If you want to quickly inspect the content of a table but don't want to fetch 
all records then you may enforce a "limiting rows" filter. You may configure
this filter using the <Leader>lr. "lr" stands for "Limit Rows". This filter
applies for all queries interactively executed from VoraX. This doesn't apply
to queries from scripts. When executing a query and such a filter is in place
VoraX will automatically add a "ROWNUM <= <number_of_rows>" clause.

The output window is also endowed with a built-in spooling feature. To
activate it you can use <Leader>sp. "sp" stands for "SPooling". As soon as
this feature is active, everything is written into the output window will be
also appended to the configured spool file. 

==============================================================================
THE CODE COMPLETION SYSTEM                                          *vorax-omni* 

We strongly believe that a good code completion system brings a lot of
efficiency in coding activities. This is a common sense feature every IDE
should have.

VoraX provides code completion for the following editing spots (contexts):

	1. In the middle of a word: VoraX will suggest: 
	
		- oracle keywords (e.g.  SELECT, SET etc.) 

		- object names (e.g. packages, tables, views etc.),

		- schema names (e.g. SYS, SYSTEM) 

		- words from the output window which match the prefix from the 
		  current word.

	2. After a dot (e.g. DBMS_STATS., MYTABLE.): the "dot" completion
	applies to: 
	
		- packages or types in order to suggest the containing
		  function and procedure names.

		- tables or views to suggest column names

		- aliases to suggest column names for the referencing table,
		  view or sub-querying

		- sequences to suggest "nextval" and "currval"

		- schemas to suggest names for the containing database objects

	3. After a "(" or a "," within a function or procedure in order to
	suggest argument names.

Invoking code completion may be done by pressing <C-x><C-o> in one of the
above editing spots but, of course, you can install the following additional
plugins which help quite a bit in this area:

	- SuperTab: http://www.vim.org/scripts/script.php?script_id=1643
	- AutocomplPop: http://www.vim.org/scripts/script.php?script_id=1879

You may tweak some aspects of the completion system using the following global
variables:

	- |g:vorax_omni_word_prefix_length| => the minimum number of chars
	  from within a word needed in order to suggest completion items. The
	  default value is 2 which means you need at least 2 characters at the
	  beginning of the word. For example, writing "D" and invoking
	  completion will not show anything, but with "DB" a lot of completion
	  items will be provided ("DBA_*, DBMS_* etc.).

	- |g:vorax_omni_skip_prefixes| => a regular expression which may be
	  used to exclude those completion prefixes which returns a lot of
	  items slowing down the system. By default is '^sys\.$' which
	  prohibits the completion system to provide a lot of items consisting
	  of all SYS objects.

Some IDEs don't let you choose how the completion items should be provided:
uppercase or lowercase. As far as I'm concerned I don't like all these items
to be in uppercase simply because they are stored like this in the Oracle
dictionary. On the other hand, I'm sure there are a lot of DBAs who may
prefer the uppercase style. To please everyone VoraX is trying to be clever:
will provide these completion items taking into consideration the first
character of the prefix. If the alias is written like "T." the columns
corresponding to this alias are given in uppercase, but the "t." alias will
provide the columns in lowercase.

==============================================================================
THE DATABASE EXPLORER                                           *vorax-explorer* 

Any decent database IDE has a database explorer/browser. Usually it is a tree
with database objects grouped according to their types: tables, views,
packages and so on.

VoraX is coming with the same approach: a Vim window/buffer showing all
database objects in a hierarchy. To toggle the database browser you may use
the <Leader>ve keymap. "ve" stands for "Vorax Explorer".

To expand, collapse or open a node you may press <Enter> or "o". To refresh a 
node you may press "R". To invoke the contextual menu for a particular database 
object you may press <Tab>.

The database explorer may be extended using custom plugins. A database
explorer plugin is a VimL script which must be located under 
vorax/plugin/explorer folder. These scripts are automatically loaded by VoraX
when the database explorer is invoked for the first time.

A database explorer plugin allows to inject a new action into the contextual
menu. For example, one might want to collect statistics for tables directly 
from the database explorer. In order to achieve that a custom explorer plugin 
can be written.

A custom plugin must implement a pre-defined interface:

		plugin = {'label' : '', 
			  'shortcut' : '', 
			  'description' : ''}

		function plugin.IsActive(path)

		function plugin.Configure()

		function plugin.Callback()

You can use g:vorax_explorer.GetPluginSkeleton() function to get a dummy
explorer plugin skeleton.

The "label" and "description" attributes are displayed into the contextual
menu. The "shortcut" is the keymap which may be used to directly invoke the
action without showing the contextual menu.

The "IsActive" function is called with the path corresponding to the current
explorer node. It must return 1 if the plugin should be active for that node
or 0 otherwise. For example, a plugin which gathers statistics should not be
active for packages, synonyms etc.

The "Configure" function is invoked once at the plugin loading time. Using
this hook the plugin can do some initializing/setup stuff.

The action, that is what the plugin is supposed to do, is coded in the 
"Callback" function. 

As soon as the plugin definition/object is created it has to be registered
using the following call:

     call g:vorax_explorer.RegisterPlugin(<unique_name>, <plugin_object>)

The unique name is typically the plugin filename script.
You can find some real examples of explorer plugins into the vorax/plugin/explorer/
folder.

vim:ts=8 sw=8 noexpandtab tw=78 ft=help:
